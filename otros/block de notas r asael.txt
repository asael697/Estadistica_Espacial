library(MASS)
library(lubridate)
library(readr)
library(dplyr)
library(readxl)
library(tibble)
library(WriteXLS)
library(tidyverse)
library(datos)
library(profvis)
library(timeDate)
library(timeSeries)
library(ggfortify)
library(dlm)
library(coda)
library(LaplacesDemon)
library(fExtremes)
library(extRemes)
library(car)
library(carData)
library(evdbayes)
library(coda)
library(compiler)
library(evir)
library(ggplot2)
library(openxlsx)
library(MARSS)
library(MASS)
library(ggplot2)
library(openxlsx)
library(revdbayes)
library(loo)
library(bayesplot)
library(posterior)
library(loo)
library(caret)

               
DLMG=function(m0,C0,FF,G,V,W,T,n,p,Xt,muestra){
  #m0=0;C0=0.6;FF=1;G=1;V=1;W=1;T=length(Go);n=1;p=1;Xt=t(Go);
  
  at=matrix(ncol=T,nrow=p)
  Rt=array(dim=c(T,p,p))
  ft=matrix(ncol=T,nrow=n)
  Qt=matrix(ncol=T,nrow=n)
  Ct=array(dim=c(T,p,p))
  mt=matrix(ncol=T,nrow=p)
  et=matrix(ncol=T,nrow=n)
  At=array(dim=c(T,p,n))
  
  mts=matrix(ncol=T,nrow=p)
  Cts=array(dim=c(T,p,p))
  Bts=array(dim=c(T,p,p))
  
  #  theta=matrix(ncol=T,nrow=p)
  ##	ECUACIONES ACTUALIZACION PARA t=1, ... ,length(Go).
  ##t=1
  
  M_t=matrix(0,ncol=T,nrow=p)
  theta_t=matrix(0,ncol=T,nrow=p)
  Theta_t_mayus=matrix(0,ncol=T,nrow=p)
  
  h_t=matrix(0,ncol=T,nrow=n)
  H_t=matrix(0,ncol=T,nrow=n)
  #Theta_t_mayus=matrix(0,ncol=T,nrow=p)
  
  
  at[,1] = G%*%m0
  Rt[1,,] = (G%*%C0%*%t(G))+W
  ft[,1] = FF%*%at[,1]
  Qt[,1] = FF%*%Rt[1,,]%*%t(FF) + V
  At[1,,] = Rt[1,,]%*%t(FF)%*%solve(Qt[,1])
  et[,1] = Xt[,1] - ft[,1]  
  mt[,1] = at[,1] + At[1,,]%*%t(et[,1])
  Ct[1,,] = Rt[1,,] - At[1,,]%*%t(Qt[1,1])%*%t(At[1,,])
  
  
  #forward Filter
  for(t in 2:T){
    at[,t] = G%*%mt[,t-1]    
    Rt[t,,] = (G%*%Ct[t-1,,]%*%t(G)) + W
    ft[,t] = FF%*%at[,t]
    Qt[,t] = FF%*%Rt[t,,]%*%t(FF) + V
    At[t,,] = Rt[t,,]%*%t(FF)%*%solve(Qt[,t])
    et[,t] = Xt[,t] - ft[,t]  
    mt[,t] = at[,t] + At[t,,]%*%t(et[,t])
    Ct[t,,] = Rt[t,,] - At[t,,]%*%t(Qt[,t])%*%t(At[t,,])
    
    
    theta_t[,t] = rnorm(1 , mean =at[,t], sd = sqrt(Rt[t,,]))
    M_t[,t] = rnorm(1, mean = ft[,t] , sd = sqrt(Qt[,t]))
    Theta_t_mayus[,t] = rnorm(1 , mean = M_t[,t] , sd = sqrt(Ct[t,,]))
    
    H_t[,t] = solve(solve(Ct[t,,])+t(G)%*%solve(W)%*%G)
    h_t[,t] = H_t[,t]%*%(solve(Ct[t,,])%*%mt[,t] + t(G)%*%solve(W)%*%M_t[,t])
  }
  #BACKWAR SAMPLIN
  if(muestra==1){
    mus = rep(0,T)
    mus[T] = rnorm(1,at[,T],sqrt(Ct[T,,]))
    for (t in (T-1):1) {
      mus[t]=rnorm(1,h_t[,(t+1)],sqrt(H_t[,(t+1)]))
    }
  }else{
    #mus = matrix(0,muestra,T)
    mus=array(dim=c(T,muestra,p))
    mus[T,,]=rnorm(muestra,at[,T],sqrt(Ct[T,,]))
    for (t in (T-1):1) {
      mus[t,,]=rnorm(muestra,h_t[,(t+1)],sqrt(H_t[,(t+1)]))
    }
  }
  #list(mus=mus,M_t=M_t)  
  return(mus)
  ##list(theta_t = theta_t , M_t = M_t , Theta_t_mayus = Theta_t_mayus)
  ##list(ft=ft,Qt=Qt,mt=mt,Ct=Ct,At=At,et=et,at=at,Rt=Rt)
} 


#prueba de datos

test<-rnorm(1000,mean=0,sd=1)

#obtener el parametro mu mediante dlm FFBS (sacamos la media de esos datos)

Go<-test
tam<-length(Go)

mu_dlm<-mean(DLMG(m0=0,C0=0.6,FF=1,G=1,V=1,W=1,T=tam,n=1,p=1,Xt=t(Go),muestra=1000))

#pasamos los datos al metropolis via paquete evdbayes


mat <- diag(c(1000, 50, 100))  #matriz diagonal

#prioris para los parantros pueden mejorar si se gusta

pn <- prior.norm(mean = c(0,0,0), cov = mat) 

#valores para la postriorio vio metropolis

t0 <- c(mu_dlm , 1.3 , 0.4) ; #s <- c(.02,.01,.1)

s<- c(.1,.05,.04)

ptpmc <- posterior(length(test), t0, prior = pn, lh = "gev", data = temp_1, psd = s)


#ptpmc guara las estimaciones de los 3 parametros (length(test) puede ponerse mayor)


post = ptpmc
post = rbind(ptpmc,post)
post = rbind(ptpmc,post)
post = rbind(ptpmc,post)

post = as.data.frame(post)
#post$.chain = sort(rep(1:4,5000))
post_df = as_draws_df(post)


y_rep = apply(post, 1, function(z){
  z = as.numeric(z)
  revd(length(ts),loc=z[1],scale=z[2],shape=z[3],type="GEV")
  #revd(908,loc = ptpmc[,1],scale=ptpmc[,2],shape=ptpmc[,3],type ="GEV")
})


ye2<-t(y_rep)

#data frame para analisas predicion


N <- length(test)
df <- data.frame(
  y = as.numeric(test),
  year = as.numeric(time(test)),
  time = 1:N
)


preds <- cbind(
  Estimate = colMeans(ye2), 
  Q5 = apply(ye2, 2, quantile, probs = 0.05),
  Q95 = apply(ye2, 2, quantile, probs = 0.95)
)


ggplot(cbind(df, preds), aes(x = year, y = Estimate)) +
  geom_smooth(aes(ymin = Q5, ymax = Q95), stat = "identity", size = 0.5) +
  geom_point(aes(y = y)) + 
  labs(
    y = "Nivel Agua", 
    x = "Anhos") 

#podemos usar para ver los graficos 

ppc_ribbon(test,ye2)